name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  packages: write

env:
  GO_VERSION: '1.23.3'
  DOCKER_IMAGE: 'share-screen'
  REGISTRY: 'ghcr.io'

jobs:
  # Environment Dependencies Check
  check-env:
    name: ğŸ” Check Environment Dependencies
    runs-on: ubuntu-latest
    outputs:
      should-deploy-prod: ${{ steps.check-secrets.outputs.should-deploy-prod }}
      should-deploy-staging: ${{ steps.check-secrets.outputs.should-deploy-staging }}

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ” Check required secrets and environment
      id: check-secrets
      run: |
        echo "ğŸ” Checking environment dependencies..."

        # Initialize deployment flags
        SHOULD_DEPLOY_PROD="false"
        SHOULD_DEPLOY_STAGING="false"

        echo "ğŸ“‹ Branch: ${{ github.ref_name }}"
        echo "ğŸ“‹ Event: ${{ github.event_name }}"

        # Check if we should attempt production deployment
        if [[ "${{ github.ref }}" == "refs/heads/main" && "${{ github.event_name }}" == "push" ]]; then
          echo "ğŸ¯ Production deployment conditions met, checking secrets..."

          # Check production secrets
          MISSING_PROD_SECRETS=""
          if [ -z "${{ secrets.SSH_USER }}" ]; then MISSING_PROD_SECRETS="$MISSING_PROD_SECRETS SSH_USER"; fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then MISSING_PROD_SECRETS="$MISSING_PROD_SECRETS SSH_PRIVATE_KEY"; fi
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then MISSING_PROD_SECRETS="$MISSING_PROD_SECRETS SERVER_HOST"; fi
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then MISSING_PROD_SECRETS="$MISSING_PROD_SECRETS DEPLOY_PATH"; fi

          if [ -n "$MISSING_PROD_SECRETS" ]; then
            echo "âŒ Production deployment DISABLED - Missing required secrets:$MISSING_PROD_SECRETS"
            echo "ğŸ“– Please configure these secrets in GitHub Settings â†’ Secrets and variables â†’ Actions"
          else
            echo "âœ… Production deployment ENABLED - All required secrets configured"
            SHOULD_DEPLOY_PROD="true"
          fi
        else
          echo "â­ï¸ Production deployment skipped (not main branch push)"
        fi

        # Check if we should attempt staging deployment
        if [[ "${{ github.ref }}" == "refs/heads/develop" && "${{ github.event_name }}" == "push" ]] || [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
          echo "ğŸ¯ Staging deployment conditions met, checking secrets..."

          # Check staging secrets
          MISSING_STAGING_SECRETS=""
          if [ -z "${{ secrets.STAGING_SSH_USER }}" ]; then MISSING_STAGING_SECRETS="$MISSING_STAGING_SECRETS STAGING_SSH_USER"; fi
          if [ -z "${{ secrets.STAGING_SSH_PRIVATE_KEY }}" ]; then MISSING_STAGING_SECRETS="$MISSING_STAGING_SECRETS STAGING_SSH_PRIVATE_KEY"; fi
          if [ -z "${{ secrets.STAGING_SERVER_HOST }}" ]; then MISSING_STAGING_SECRETS="$MISSING_STAGING_SECRETS STAGING_SERVER_HOST"; fi
          if [ -z "${{ secrets.STAGING_DEPLOY_PATH }}" ]; then MISSING_STAGING_SECRETS="$MISSING_STAGING_SECRETS STAGING_DEPLOY_PATH"; fi

          if [ -n "$MISSING_STAGING_SECRETS" ]; then
            echo "âŒ Staging deployment DISABLED - Missing required secrets:$MISSING_STAGING_SECRETS"
            echo "ğŸ“– Please configure these secrets in GitHub Settings â†’ Secrets and variables â†’ Actions"
          else
            echo "âœ… Staging deployment ENABLED - All required secrets configured"
            SHOULD_DEPLOY_STAGING="true"
          fi
        else
          echo "â­ï¸ Staging deployment skipped (not develop branch push or force deploy)"
        fi

        # Set outputs
        echo "should-deploy-prod=$SHOULD_DEPLOY_PROD" >> $GITHUB_OUTPUT
        echo "should-deploy-staging=$SHOULD_DEPLOY_STAGING" >> $GITHUB_OUTPUT

        echo ""
        echo "ğŸ¯ Deployment Summary:"
        echo "  Production: $SHOULD_DEPLOY_PROD"
        echo "  Staging: $SHOULD_DEPLOY_STAGING"

  # Test and Quality Assurance
  test:
    name: ğŸ§ª Test & Quality Check
    runs-on: ubuntu-latest
    needs: check-env

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ¹ Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: ğŸ“¦ Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: ğŸ“¥ Download dependencies
      run: go mod download

    - name: ğŸ” Verify dependencies
      run: go mod verify

    - name: ğŸ§¹ Format check
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "âŒ Code is not properly formatted:"
          gofmt -s -l .
          exit 1
        fi
        echo "âœ… Code is properly formatted"

    - name: ğŸ” Vet check
      run: go vet ./...

    - name: ğŸ§ª Run tests with coverage
      run: |
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        go tool cover -html=coverage.out -o coverage.html

    - name: ğŸ“Š Display test coverage
      run: go tool cover -func=coverage.out

    - name: ğŸ“¤ Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage.out
          coverage.html

    - name: ğŸ—ï¸ Test build
      run: go build -v ./...

  # Security Scanning
  security:
    name: ğŸ”’ Security & Quality Scan
    runs-on: ubuntu-latest
    needs: [check-env, test]

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ¹ Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: ğŸ“¦ Download dependencies
      run: go mod download

    - name: ğŸ” Run Go Security Scanner
      run: |
        echo "ğŸ” Running security and quality checks..."

        # Run go vet for potential issues
        echo "ğŸ“‹ Running go vet..."
        go vet ./...

        # Check for common security patterns
        echo "ğŸ”’ Checking for security patterns..."

        # Check for hardcoded credentials (basic check)
        if grep -r -i --include="*.go" "password.*=.*[\"'].*[\"']\|secret.*=.*[\"'].*[\"']\|api.*key.*=.*[\"'].*[\"']" . | grep -v "_test.go" | grep -v "mock" | grep -v "example" | grep -v "flag\|env\|config"; then
          echo "âš ï¸ Potential hardcoded credentials found"
          exit 1
        fi

        # Check for SQL injection patterns
        if grep -r --include="*.go" "fmt.Sprintf.*%.*SELECT\|fmt.Sprintf.*%.*INSERT\|fmt.Sprintf.*%.*UPDATE" .; then
          echo "âš ï¸ Potential SQL injection patterns found"
          exit 1
        fi

        # Check for unsafe use of crypto/md5 or crypto/sha1
        if grep -r --include="*.go" "crypto/md5\|crypto/sha1" . | grep -v "_test.go"; then
          echo "âš ï¸ Unsafe cryptographic functions found (md5/sha1)"
          exit 1
        fi

        echo "âœ… Basic security checks passed"

    - name: ğŸ—ï¸ Advanced Build Check
      run: |
        echo "ğŸ—ï¸ Running advanced build checks..."

        # Build with race detector
        go build -race ./...

        # Check for unused dependencies
        go mod tidy
        if ! git diff --quiet go.mod; then
          echo "âš ï¸ go.mod not tidy"
          git diff go.mod
          exit 1
        fi

        # Check go.sum only if it exists
        if [ -f go.sum ] && ! git diff --quiet go.sum; then
          echo "âš ï¸ go.sum not tidy"
          git diff go.sum
          exit 1
        fi

        echo "âœ… Advanced build checks passed"

    - name: ğŸ“Š Security scan summary
      run: |
        echo "ğŸ›¡ï¸ Security scan completed successfully!"
        echo "âœ… Go vet checks passed"
        echo "âœ… Basic security patterns checked"
        echo "âœ… No hardcoded credentials detected"
        echo "âœ… No unsafe crypto usage detected"
        echo "âœ… Dependencies are tidy"

  # Build Docker Image
  build:
    name: ğŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: [check-env, test, security]

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ” Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ“ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/rhyanz46/${{ env.DOCKER_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: ğŸ—ï¸ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ğŸ§ª Test Docker image
      run: |
        docker run --rm ${{ env.REGISTRY }}/rhyanz46/${{ env.DOCKER_IMAGE }}:latest --help

  # Deploy to Server (only if secrets configured)
  deploy:
    name: ğŸš€ Deploy to Server
    runs-on: ubuntu-latest
    needs: [check-env, test, security, build]
    if: needs.check-env.outputs.should-deploy-prod == 'true'
    environment: production

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ” Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: ğŸŒ Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: ğŸ“‚ Create deployment directory
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          mkdir -p ${{ secrets.DEPLOY_PATH }}
        "

    - name: ğŸ“¤ Copy files to server
      run: |
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='coverage.*' \
          --exclude='*.test' \
          --exclude='bin/' \
          ./ ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/


    - name: ğŸš€ Deploy with Docker Compose
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Stop existing containers
          docker compose down || true

          # Set environment variables from GitHub secrets
          export PORT=${{ secrets.PROD_PORT || '8080' }}
          export HTTP_PORT=${{ secrets.PROD_HTTP_PORT || '8080' }}
          export HTTPS_PORT=${{ secrets.PROD_HTTPS_PORT || '8443' }}
          export ENABLE_HTTPS=${{ secrets.PROD_ENABLE_HTTPS || 'true' }}
          export STUN_SERVER='${{ secrets.PROD_STUN_SERVER || 'stun:stun.l.google.com:19302' }}'
          export TOKEN_EXPIRY='${{ secrets.PROD_TOKEN_EXPIRY || '30m' }}'
          export TLS_CERT_FILE='${{ secrets.PROD_TLS_CERT_FILE || '/certs/server.crt' }}'
          export TLS_KEY_FILE='${{ secrets.PROD_TLS_KEY_FILE || '/certs/server.key' }}'

          # Build and start containers with environment variables
          docker compose up -d --build

          # Wait for containers to be ready
          sleep 15
        "

    - name: ğŸ©º Health check
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Set port from environment
          HEALTH_CHECK_PORT=${{ secrets.PROD_HTTP_PORT || '8080' }}

          # Check if containers are running
          if docker compose ps | grep -q 'Up'; then
            echo 'âœ… Docker containers are running'
          else
            echo 'âŒ Docker containers failed to start'
            docker compose logs
            exit 1
          fi

          # Check if port is listening
          if ss -tlnp | grep :\$HEALTH_CHECK_PORT; then
            echo 'âœ… Application is listening on port '\$HEALTH_CHECK_PORT
          else
            echo 'âŒ Application is not listening on expected port '\$HEALTH_CHECK_PORT
            exit 1
          fi

          # Test HTTP endpoint
          if curl -f -s http://localhost:\$HEALTH_CHECK_PORT/ > /dev/null 2>&1; then
            echo 'âœ… HTTP endpoint is responding'
          else
            echo 'âš ï¸ HTTP endpoint test failed (might be expected if app requires specific paths)'
          fi
        "

    - name: ğŸ“Š Deployment Summary
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸ“… Deployed at: $(date)"
        echo "ğŸŒ Server: ${{ secrets.SERVER_HOST }}"
        echo "ğŸ“‚ Path: ${{ secrets.DEPLOY_PATH }}"
        echo "ğŸ³ Deployment: Docker Compose"
        echo "ğŸ“± HTTP: http://${{ secrets.SERVER_HOST }}:${{ secrets.PROD_HTTP_PORT || '8080' }}"
        echo "ğŸ”’ HTTPS: https://${{ secrets.SERVER_HOST }}:${{ secrets.PROD_HTTPS_PORT || '8443' }}"

  # Notification
  notify:
    name: ğŸ“¢ Notify Deployment
    runs-on: ubuntu-latest
    needs: [check-env, deploy]
    if: always() && needs.check-env.outputs.should-deploy-prod == 'true'

    steps:
    - name: ğŸ“¢ Send notification
      uses: 8398a7/action-slack@v3
      if: env.SLACK_WEBHOOK != ''
      with:
        status: ${{ needs.deploy.result }}
        channel: '#deployments'
        text: |
          ğŸš€ Share Screen deployment ${{ needs.deploy.result }}
          ğŸ“… Branch: ${{ github.ref_name }}
          ğŸ‘¤ Author: ${{ github.actor }}
          ğŸ“ Commit: ${{ github.event.head_commit.message }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}