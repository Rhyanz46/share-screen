name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.23.3'
  DOCKER_IMAGE: 'share-screen'
  REGISTRY: 'ghcr.io'

jobs:
  # Test and Quality Assurance
  test:
    name: ðŸ§ª Test & Quality Check
    runs-on: ubuntu-latest

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ¹ Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: ðŸ“¦ Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: ðŸ“¥ Download dependencies
      run: go mod download

    - name: ðŸ” Verify dependencies
      run: go mod verify

    - name: ðŸ§¹ Format check
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "âŒ Code is not properly formatted:"
          gofmt -s -l .
          exit 1
        fi
        echo "âœ… Code is properly formatted"

    - name: ðŸ”Ž Vet check
      run: go vet ./...

    - name: ðŸ§ª Run tests with coverage
      run: |
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        go tool cover -html=coverage.out -o coverage.html

    - name: ðŸ“Š Display test coverage
      run: go tool cover -func=coverage.out

    - name: ðŸ“¤ Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage.out
          coverage.html

    - name: ðŸ—ï¸ Test build
      run: go build -v ./...

  # Security Scanning
  security:
    name: ðŸ”’ Security & Quality Scan
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ¹ Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: ðŸ“¦ Download dependencies
      run: go mod download

    - name: ðŸ” Run Go Security Scanner
      run: |
        echo "ðŸ” Running security and quality checks..."

        # Run go vet for potential issues
        echo "ðŸ“‹ Running go vet..."
        go vet ./...

        # Check for common security patterns
        echo "ðŸ”’ Checking for security patterns..."

        # Check for hardcoded credentials (basic check)
        if grep -r -i --include="*.go" "password.*=.*[\"'].*[\"']\|secret.*=.*[\"'].*[\"']\|api.*key.*=.*[\"'].*[\"']" . | grep -v "_test.go" | grep -v "mock" | grep -v "example" | grep -v "flag\|env\|config"; then
          echo "âš ï¸ Potential hardcoded credentials found"
          exit 1
        fi

        # Check for SQL injection patterns
        if grep -r --include="*.go" "fmt.Sprintf.*%.*SELECT\|fmt.Sprintf.*%.*INSERT\|fmt.Sprintf.*%.*UPDATE" .; then
          echo "âš ï¸ Potential SQL injection patterns found"
          exit 1
        fi

        # Check for unsafe use of crypto/md5 or crypto/sha1
        if grep -r --include="*.go" "crypto/md5\|crypto/sha1" . | grep -v "_test.go"; then
          echo "âš ï¸ Unsafe cryptographic functions found (md5/sha1)"
          exit 1
        fi

        echo "âœ… Basic security checks passed"

    - name: ðŸ—ï¸ Advanced Build Check
      run: |
        echo "ðŸ—ï¸ Running advanced build checks..."

        # Build with race detector
        go build -race ./...

        # Check for unused dependencies
        go mod tidy
        if ! git diff --quiet go.mod go.sum; then
          echo "âš ï¸ go.mod/go.sum not tidy"
          git diff go.mod go.sum
          exit 1
        fi

        echo "âœ… Advanced build checks passed"

    - name: ðŸ“Š Security scan summary
      run: |
        echo "ðŸ›¡ï¸ Security scan completed successfully!"
        echo "âœ… Go vet checks passed"
        echo "âœ… Basic security patterns checked"
        echo "âœ… No hardcoded credentials detected"
        echo "âœ… No unsafe crypto usage detected"
        echo "âœ… Dependencies are tidy"

  # Build Docker Image
  build:
    name: ðŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: [test, security]

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v4

    - name: ðŸ” Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v4
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ðŸ“ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: ðŸ—ï¸ Build and push Docker image
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ðŸ§ª Test Docker image
      run: |
        docker run --rm ${{ env.REGISTRY }}/${{ github.repository }}:latest --help

  # Deploy to Server (only on main branch)
  deploy:
    name: ðŸš€ Deploy to Server
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ” Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: ðŸŒ Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: ðŸ“‚ Create deployment directory
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          sudo mkdir -p ${{ secrets.DEPLOY_PATH }}
          sudo chown ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} ${{ secrets.DEPLOY_PATH }}
        "

    - name: ðŸ“¤ Copy files to server
      run: |
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='coverage.*' \
          --exclude='*.test' \
          ./ ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/

    - name: ðŸ—ï¸ Build application on server
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}
          go mod download
          go build -o bin/share-screen .
        "

    - name: ðŸ”§ Setup systemd service
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          sudo tee /etc/systemd/system/share-screen.service > /dev/null << 'EOF'
        [Unit]
        Description=Share Screen Application
        After=network.target

        [Service]
        Type=simple
        User=${{ secrets.SSH_USER }}
        WorkingDirectory=${{ secrets.DEPLOY_PATH }}
        ExecStart=${{ secrets.DEPLOY_PATH }}/bin/share-screen
        Environment=PORT=8080
        Environment=ENABLE_HTTPS=true
        Environment=TLS_CERT_FILE=${{ secrets.DEPLOY_PATH }}/certs/server.crt
        Environment=TLS_KEY_FILE=${{ secrets.DEPLOY_PATH }}/certs/server.key
        Environment=STUN_SERVER=stun:stun.l.google.com:19302
        Environment=TOKEN_EXPIRY=30m
        Restart=always
        RestartSec=5
        StandardOutput=journal
        StandardError=journal

        [Install]
        WantedBy=multi-user.target
        EOF
        "

    - name: ðŸ” Generate SSL certificates
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}
          if [ ! -f certs/server.crt ]; then
            mkdir -p certs
            chmod +x scripts/generate-certs.sh
            ./scripts/generate-certs.sh
          fi
        "

    - name: ðŸ”„ Restart service
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          sudo systemctl daemon-reload
          sudo systemctl enable share-screen
          sudo systemctl restart share-screen
          sleep 5
          sudo systemctl status share-screen
        "

    - name: ðŸ©º Health check
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          # Wait for service to start
          sleep 10

          # Check if service is running
          if sudo systemctl is-active --quiet share-screen; then
            echo 'âœ… Service is running'
          else
            echo 'âŒ Service failed to start'
            sudo journalctl -u share-screen --no-pager -l
            exit 1
          fi

          # Check if port is listening
          if ss -tlnp | grep :8080; then
            echo 'âœ… Application is listening on port 8080'
          else
            echo 'âŒ Application is not listening on expected port'
            exit 1
          fi
        "

    - name: ðŸ“Š Deployment Summary
      run: |
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "ðŸ“… Deployed at: $(date)"
        echo "ðŸŒ Server: ${{ secrets.SERVER_HOST }}"
        echo "ðŸ“‚ Path: ${{ secrets.DEPLOY_PATH }}"
        echo "ðŸš€ Service: share-screen.service"

  # Notification
  notify:
    name: ðŸ“¢ Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && github.ref == 'refs/heads/main'

    steps:
    - name: ðŸ“¢ Send notification
      uses: 8398a7/action-slack@v3
      if: env.SLACK_WEBHOOK != ''
      with:
        status: ${{ needs.deploy.result }}
        channel: '#deployments'
        text: |
          ðŸš€ Share Screen deployment ${{ needs.deploy.result }}
          ðŸ“… Branch: ${{ github.ref_name }}
          ðŸ‘¤ Author: ${{ github.actor }}
          ðŸ“ Commit: ${{ github.event.head_commit.message }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}