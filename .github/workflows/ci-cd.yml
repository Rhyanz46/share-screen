name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.23.3'
  DOCKER_IMAGE: 'share-screen'
  REGISTRY: 'ghcr.io'

jobs:
  # Test and Quality Assurance
  test:
    name: 🧪 Test & Quality Check
    runs-on: ubuntu-latest

    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🐹 Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: 📦 Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: 📥 Download dependencies
      run: go mod download

    - name: 🔍 Verify dependencies
      run: go mod verify

    - name: 🧹 Format check
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "❌ Code is not properly formatted:"
          gofmt -s -l .
          exit 1
        fi
        echo "✅ Code is properly formatted"

    - name: 🔎 Vet check
      run: go vet ./...

    - name: 🧪 Run tests with coverage
      run: |
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        go tool cover -html=coverage.out -o coverage.html

    - name: 📊 Display test coverage
      run: go tool cover -func=coverage.out

    - name: 📤 Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage.out
          coverage.html

    - name: 🏗️ Test build
      run: go build -v ./...

  # Security Scanning
  security:
    name: 🔒 Security & Quality Scan
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🐹 Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: 📦 Download dependencies
      run: go mod download

    - name: 🔍 Run Go Security Scanner
      run: |
        echo "🔍 Running security and quality checks..."

        # Run go vet for potential issues
        echo "📋 Running go vet..."
        go vet ./...

        # Check for common security patterns
        echo "🔒 Checking for security patterns..."

        # Check for hardcoded credentials (basic check)
        if grep -r -i --include="*.go" "password.*=.*[\"'].*[\"']\|secret.*=.*[\"'].*[\"']\|api.*key.*=.*[\"'].*[\"']" . | grep -v "_test.go" | grep -v "mock" | grep -v "example" | grep -v "flag\|env\|config"; then
          echo "⚠️ Potential hardcoded credentials found"
          exit 1
        fi

        # Check for SQL injection patterns
        if grep -r --include="*.go" "fmt.Sprintf.*%.*SELECT\|fmt.Sprintf.*%.*INSERT\|fmt.Sprintf.*%.*UPDATE" .; then
          echo "⚠️ Potential SQL injection patterns found"
          exit 1
        fi

        # Check for unsafe use of crypto/md5 or crypto/sha1
        if grep -r --include="*.go" "crypto/md5\|crypto/sha1" . | grep -v "_test.go"; then
          echo "⚠️ Unsafe cryptographic functions found (md5/sha1)"
          exit 1
        fi

        echo "✅ Basic security checks passed"

    - name: 🏗️ Advanced Build Check
      run: |
        echo "🏗️ Running advanced build checks..."

        # Build with race detector
        go build -race ./...

        # Check for unused dependencies
        go mod tidy
        if ! git diff --quiet go.mod; then
          echo "⚠️ go.mod not tidy"
          git diff go.mod
          exit 1
        fi

        # Check go.sum only if it exists
        if [ -f go.sum ] && ! git diff --quiet go.sum; then
          echo "⚠️ go.sum not tidy"
          git diff go.sum
          exit 1
        fi

        echo "✅ Advanced build checks passed"

    - name: 📊 Security scan summary
      run: |
        echo "🛡️ Security scan completed successfully!"
        echo "✅ Go vet checks passed"
        echo "✅ Basic security patterns checked"
        echo "✅ No hardcoded credentials detected"
        echo "✅ No unsafe crypto usage detected"
        echo "✅ Dependencies are tidy"

  # Build Docker Image
  build:
    name: 🐳 Build Docker Image
    runs-on: ubuntu-latest
    needs: [test, security]

    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🐳 Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: 🔐 Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: 📝 Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: 🏗️ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: 🧪 Test Docker image
      run: |
        docker run --rm ${{ env.REGISTRY }}/${{ github.repository }}:latest --help

  # Deploy to Server (only on main branch)
  deploy:
    name: 🚀 Deploy to Server
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🔐 Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: 🌐 Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: 📂 Create deployment directory
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          mkdir -p ${{ secrets.DEPLOY_PATH }}
        "

    - name: 📤 Copy files to server
      run: |
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='coverage.*' \
          --exclude='*.test' \
          --exclude='bin/' \
          ./ ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/

    - name: 🐳 Setup Docker Compose deployment
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Create .env file for production
          cat > .env << 'EOF'
        PORT=8080
        HTTP_PORT=8080
        HTTPS_PORT=8443
        ENABLE_HTTPS=true
        STUN_SERVER=stun:stun.l.google.com:19302
        TOKEN_EXPIRY=30m
        TLS_CERT_FILE=/certs/server.crt
        TLS_KEY_FILE=/certs/server.key
        EOF
        "

    - name: 🔐 Generate SSL certificates
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}
          if [ ! -f certs/server.crt ]; then
            mkdir -p certs
            chmod +x scripts/generate-certs.sh
            ./scripts/generate-certs.sh
          fi
        "

    - name: 🚀 Deploy with Docker Compose
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Stop existing containers
          docker compose down || true

          # Build and start containers
          docker compose up -d --build

          # Wait for containers to be ready
          sleep 15
        "

    - name: 🩺 Health check
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Check if containers are running
          if docker compose ps | grep -q 'Up'; then
            echo '✅ Docker containers are running'
          else
            echo '❌ Docker containers failed to start'
            docker compose logs
            exit 1
          fi

          # Check if port is listening
          if ss -tlnp | grep :8080; then
            echo '✅ Application is listening on port 8080'
          else
            echo '❌ Application is not listening on expected port'
            exit 1
          fi

          # Test HTTP endpoint
          if curl -f -s http://localhost:8080/ > /dev/null 2>&1; then
            echo '✅ HTTP endpoint is responding'
          else
            echo '⚠️ HTTP endpoint test failed (might be expected if app requires specific paths)'
          fi
        "

    - name: 📊 Deployment Summary
      run: |
        echo "🎉 Deployment completed successfully!"
        echo "📅 Deployed at: $(date)"
        echo "🌐 Server: ${{ secrets.SERVER_HOST }}"
        echo "📂 Path: ${{ secrets.DEPLOY_PATH }}"
        echo "🐳 Deployment: Docker Compose"
        echo "📱 HTTP: http://${{ secrets.SERVER_HOST }}:8080"
        echo "🔒 HTTPS: https://${{ secrets.SERVER_HOST }}:8443"

  # Notification
  notify:
    name: 📢 Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && github.ref == 'refs/heads/main'

    steps:
    - name: 📢 Send notification
      uses: 8398a7/action-slack@v3
      if: env.SLACK_WEBHOOK != ''
      with:
        status: ${{ needs.deploy.result }}
        channel: '#deployments'
        text: |
          🚀 Share Screen deployment ${{ needs.deploy.result }}
          📅 Branch: ${{ github.ref_name }}
          👤 Author: ${{ github.actor }}
          📝 Commit: ${{ github.event.head_commit.message }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}