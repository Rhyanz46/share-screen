name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.23.3'
  DOCKER_IMAGE: 'share-screen'
  REGISTRY: 'ghcr.io'

jobs:
  # Test and Quality Assurance
  test:
    name: ğŸ§ª Test & Quality Check
    runs-on: ubuntu-latest

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ¹ Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: ğŸ“¦ Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: ğŸ“¥ Download dependencies
      run: go mod download

    - name: ğŸ” Verify dependencies
      run: go mod verify

    - name: ğŸ§¹ Format check
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "âŒ Code is not properly formatted:"
          gofmt -s -l .
          exit 1
        fi
        echo "âœ… Code is properly formatted"

    - name: ğŸ” Vet check
      run: go vet ./...

    - name: ğŸ§ª Run tests with coverage
      run: |
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        go tool cover -html=coverage.out -o coverage.html

    - name: ğŸ“Š Display test coverage
      run: go tool cover -func=coverage.out

    - name: ğŸ“¤ Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage.out
          coverage.html

    - name: ğŸ—ï¸ Test build
      run: go build -v ./...

  # Security Scanning
  security:
    name: ğŸ”’ Security & Quality Scan
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ¹ Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: ğŸ“¦ Download dependencies
      run: go mod download

    - name: ğŸ” Run Go Security Scanner
      run: |
        echo "ğŸ” Running security and quality checks..."

        # Run go vet for potential issues
        echo "ğŸ“‹ Running go vet..."
        go vet ./...

        # Check for common security patterns
        echo "ğŸ”’ Checking for security patterns..."

        # Check for hardcoded credentials (basic check)
        if grep -r -i --include="*.go" "password.*=.*[\"'].*[\"']\|secret.*=.*[\"'].*[\"']\|api.*key.*=.*[\"'].*[\"']" . | grep -v "_test.go" | grep -v "mock" | grep -v "example" | grep -v "flag\|env\|config"; then
          echo "âš ï¸ Potential hardcoded credentials found"
          exit 1
        fi

        # Check for SQL injection patterns
        if grep -r --include="*.go" "fmt.Sprintf.*%.*SELECT\|fmt.Sprintf.*%.*INSERT\|fmt.Sprintf.*%.*UPDATE" .; then
          echo "âš ï¸ Potential SQL injection patterns found"
          exit 1
        fi

        # Check for unsafe use of crypto/md5 or crypto/sha1
        if grep -r --include="*.go" "crypto/md5\|crypto/sha1" . | grep -v "_test.go"; then
          echo "âš ï¸ Unsafe cryptographic functions found (md5/sha1)"
          exit 1
        fi

        echo "âœ… Basic security checks passed"

    - name: ğŸ—ï¸ Advanced Build Check
      run: |
        echo "ğŸ—ï¸ Running advanced build checks..."

        # Build with race detector
        go build -race ./...

        # Check for unused dependencies
        go mod tidy
        if ! git diff --quiet go.mod; then
          echo "âš ï¸ go.mod not tidy"
          git diff go.mod
          exit 1
        fi

        # Check go.sum only if it exists
        if [ -f go.sum ] && ! git diff --quiet go.sum; then
          echo "âš ï¸ go.sum not tidy"
          git diff go.sum
          exit 1
        fi

        echo "âœ… Advanced build checks passed"

    - name: ğŸ“Š Security scan summary
      run: |
        echo "ğŸ›¡ï¸ Security scan completed successfully!"
        echo "âœ… Go vet checks passed"
        echo "âœ… Basic security patterns checked"
        echo "âœ… No hardcoded credentials detected"
        echo "âœ… No unsafe crypto usage detected"
        echo "âœ… Dependencies are tidy"

  # Build Docker Image
  build:
    name: ğŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: [test, security]

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ” Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ“ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: ğŸ—ï¸ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ğŸ§ª Test Docker image
      run: |
        docker run --rm ${{ env.REGISTRY }}/${{ github.repository }}:latest --help

  # Deploy to Server (only on main branch)
  deploy:
    name: ğŸš€ Deploy to Server
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ” Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: ğŸŒ Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: ğŸ“‚ Create deployment directory
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          mkdir -p ${{ secrets.DEPLOY_PATH }}
        "

    - name: ğŸ“¤ Copy files to server
      run: |
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='coverage.*' \
          --exclude='*.test' \
          --exclude='bin/' \
          ./ ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/

    - name: ğŸ³ Setup Docker Compose deployment
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Create .env file for production
          cat > .env << 'EOF'
        PORT=8080
        HTTP_PORT=8080
        HTTPS_PORT=8443
        ENABLE_HTTPS=true
        STUN_SERVER=stun:stun.l.google.com:19302
        TOKEN_EXPIRY=30m
        TLS_CERT_FILE=/certs/server.crt
        TLS_KEY_FILE=/certs/server.key
        EOF
        "

    - name: ğŸ” Generate SSL certificates
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}
          if [ ! -f certs/server.crt ]; then
            mkdir -p certs
            chmod +x scripts/generate-certs.sh
            ./scripts/generate-certs.sh
          fi
        "

    - name: ğŸš€ Deploy with Docker Compose
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Stop existing containers
          docker compose down || true

          # Build and start containers
          docker compose up -d --build

          # Wait for containers to be ready
          sleep 15
        "

    - name: ğŸ©º Health check
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "
          cd ${{ secrets.DEPLOY_PATH }}

          # Check if containers are running
          if docker compose ps | grep -q 'Up'; then
            echo 'âœ… Docker containers are running'
          else
            echo 'âŒ Docker containers failed to start'
            docker compose logs
            exit 1
          fi

          # Check if port is listening
          if ss -tlnp | grep :8080; then
            echo 'âœ… Application is listening on port 8080'
          else
            echo 'âŒ Application is not listening on expected port'
            exit 1
          fi

          # Test HTTP endpoint
          if curl -f -s http://localhost:8080/ > /dev/null 2>&1; then
            echo 'âœ… HTTP endpoint is responding'
          else
            echo 'âš ï¸ HTTP endpoint test failed (might be expected if app requires specific paths)'
          fi
        "

    - name: ğŸ“Š Deployment Summary
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸ“… Deployed at: $(date)"
        echo "ğŸŒ Server: ${{ secrets.SERVER_HOST }}"
        echo "ğŸ“‚ Path: ${{ secrets.DEPLOY_PATH }}"
        echo "ğŸ³ Deployment: Docker Compose"
        echo "ğŸ“± HTTP: http://${{ secrets.SERVER_HOST }}:8080"
        echo "ğŸ”’ HTTPS: https://${{ secrets.SERVER_HOST }}:8443"

  # Notification
  notify:
    name: ğŸ“¢ Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && github.ref == 'refs/heads/main'

    steps:
    - name: ğŸ“¢ Send notification
      uses: 8398a7/action-slack@v3
      if: env.SLACK_WEBHOOK != ''
      with:
        status: ${{ needs.deploy.result }}
        channel: '#deployments'
        text: |
          ğŸš€ Share Screen deployment ${{ needs.deploy.result }}
          ğŸ“… Branch: ${{ github.ref_name }}
          ğŸ‘¤ Author: ${{ github.actor }}
          ğŸ“ Commit: ${{ github.event.head_commit.message }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}